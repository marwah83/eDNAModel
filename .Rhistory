phyloseq_obj = physeq_obj,
min_species_sum = min_species_sum,
save_path = NULL
)
# Extract metadata
meta_df <- as.data.frame(phyloseq::sample_data(physeq_filtered))
# Filter to sampletype of interest
meta_df <- meta_df[meta_df[[col_vars$sampletype]] == sampletype_keep, ]
# Subset phyloseq object again based on filtered samples
physeq_filtered <- phyloseq::prune_samples(rownames(meta_df), physeq_filtered)
# Assign standardized column names from user-specified mapping
meta_df$Sample    <- factor(trimws(meta_df[[col_vars$sample]]))
meta_df$Replicate <- factor(trimws(meta_df[[col_vars$samplerep]]))
meta_df$Site      <- factor(trimws(meta_df[[col_vars$location]]))
meta_df$treatment <- factor(trimws(meta_df[[col_vars$treatment]]))
# Optional columns
if (!is.null(col_vars$atoll) && col_vars$atoll %in% colnames(meta_df)) {
meta_df$atoll <- factor(trimws(meta_df[[col_vars$atoll]]))
}
if (!is.null(col_vars$exblank) && col_vars$exblank %in% colnames(meta_df)) {
meta_df$exblank <- trimws(meta_df[[col_vars$exblank]])
}
if (!is.null(col_vars$samp.blank) && col_vars$samp.blank %in% colnames(meta_df)) {
meta_df$samp.blank <- trimws(meta_df[[col_vars$samp.blank]])
}
# Reshape OTU table
otu_df <- as.data.frame(phyloseq::otu_table(physeq_filtered))
otu_df$SampleID <- rownames(otu_df)
long_df <- tidyr::pivot_longer(
otu_df,
cols = -SampleID,
names_to = "i",
values_to = "y"
)
# Merge with metadata
long_df <- merge(long_df, meta_df, by.x = "SampleID", by.y = "row.names")
# Ensure proper types
long_df$i <- factor(long_df$i)
long_df$y <- as.integer(long_df$y)
# Assemble final column order dynamically
default_cols <- c("i", "Site", "Sample", "Replicate", "treatment", "y")
optional_cols <- c("atoll", "exblank", "samp.blank")
present_optional_cols <- optional_cols[optional_cols %in% colnames(long_df)]
final_cols <- c(default_cols, present_optional_cols)
final_cols <- final_cols[final_cols %in% colnames(long_df)]  # ensure they exist
# Subset and return
long_df <- long_df[, final_cols, drop = FALSE]
return(list(
physeq_filtered = physeq_filtered,
long_df = long_df
))
}
col_map <- list(
sampletype = "sampletype",
location   = "location",
treatment  = "treatment",
sample     = "sample",
samplerep  = "samplerep",
atoll      = "atoll",
exblank    = "exblank",
samp.blank = "samp.blank"
)
physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
physeq <- readRDS(physeq_path)
out_data <- prepare_long_data(
physeq_obj        = physeq,
min_species_sum   = 50,
sampletype_keep   = "biologicalsample",
col_vars          = col_map
)
View(out_data)
View(out_data$long_df)
str(out_data$long_df)
#' Prepare Long-format OTU Data from a phyloseq Object
#'
#' Filters and reshapes a phyloseq object into long format for occupancy-abundance modeling.
#'
#' @param physeq_obj A `phyloseq` object.
#' @param min_species_sum Minimum abundance to retain a taxon (default: 50).
#' @param sampletype_keep The value of `sampletype` to retain (default: "biologicalsample").
#' @param col_vars A named list mapping the following required fields:
#'   - "sampletype"
#'   - "location"
#'   - "treatment"
#'   - "sample"
#'   - "samplerep"
#'   Any other variables in the list will also be carried through to output.
#' @param save_path Optional path to save the filtered object.
#'
#' @return A list with:
#' \describe{
#'   \item{physeq_filtered}{Filtered `phyloseq` object}
#'   \item{long_df}{Long-format data frame with counts and metadata}
#' }
#' @export
prepare_long_data <- function(physeq_obj,
min_species_sum = 50,
sampletype_keep = "biologicalsample",
col_vars = list(
sampletype = "sampletype",
location = "location",
treatment = "treatment",
sample = "sample",
samplerep = "samplerep"
),
save_path = NULL) {
# ==== Validate col_vars ====
required_keys <- c("sampletype", "location", "treatment", "sample", "samplerep")
missing_keys <- setdiff(required_keys, names(col_vars))
if (length(missing_keys) > 0) {
stop("Missing required `col_vars`: ", paste(missing_keys, collapse = ", "))
}
# ==== Filter by abundance ====
physeq_filtered <- filter_phyloseq_data(
phyloseq_obj = physeq_obj,
min_species_sum = min_species_sum,
save_path = save_path
)
sample_meta <- as.data.frame(sample_data(physeq_filtered), stringsAsFactors = FALSE)
# ==== Filter by sampletype ====
sampletype_col <- col_vars$sampletype
if (!sampletype_col %in% colnames(sample_meta)) {
stop("Column '", sampletype_col, "' not found in sample_data.")
}
keep_samples <- rownames(sample_meta[sample_meta[[sampletype_col]] == sampletype_keep, ])
physeq_bio <- prune_samples(keep_samples, physeq_filtered)
# ==== Extract & assign sample + replicate ====
sample_names_vec <- sample_names(physeq_bio)
parsed <- tryCatch({
strcapture(
pattern = "^(.*)_r([0-9]+)$",
x = sample_names_vec,
proto = list(Sample = character(), Replicate = integer())
)
}, error = function(e) {
warning("âš ï¸ Failed to parse replicates: ", e$message)
data.frame(Sample = sample_names_vec, Replicate = 1)
})
parsed$Sample[is.na(parsed$Sample)] <- sample_names_vec[is.na(parsed$Sample)]
parsed$Replicate[is.na(parsed$Replicate)] <- 1
parsed$Sample <- factor(parsed$Sample)
parsed$Replicate <- factor(parsed$Replicate)
sample_data(physeq_bio)$Sample <- parsed$Sample
sample_data(physeq_bio)$Replicate <- parsed$Replicate
sample_data(physeq_bio)$SampleRep <- interaction(parsed$Sample, parsed$Replicate)
# ==== Prepare metadata ====
meta_df <- as.data.frame(sample_data(physeq_bio), stringsAsFactors = FALSE)
meta_df$Site <- factor(trimws(meta_df[[col_vars$location]]))
meta_df[[col_vars$location]] <- NULL
sample_data(physeq_bio) <- phyloseq::sample_data(meta_df)
# ==== Filter rare taxa ====
physeq_bio_filtered <- filter_taxa(physeq_bio, function(x) sum(x > 0) > 5, prune = TRUE)
# ==== Convert to long format ====
otu_mat <- as(otu_table(physeq_bio_filtered), "matrix")
if (taxa_are_rows(physeq_bio_filtered)) otu_mat <- t(otu_mat)
otu_long <- as.data.frame(otu_mat) %>%
tibble::rownames_to_column(var = "SampleRep") %>%
tidyr::pivot_longer(-SampleRep, names_to = "i", values_to = "y")
# ==== Clean metadata & join ====
meta_df <- as.data.frame(sample_data(physeq_bio_filtered), stringsAsFactors = FALSE)
meta_df$SampleRep <- rownames(meta_df)
long_df <- dplyr::left_join(otu_long, meta_df, by = "SampleRep") %>%
mutate(
i = factor(i),
y = as.integer(y)
)
# ==== Build column list ====
output_cols <- c(
"i", "Site", "Sample", "Replicate", col_vars$treatment,
setdiff(names(col_vars), required_keys)  # include any extra columns
)
output_cols <- unique(output_cols[output_cols %in% colnames(long_df)])
long_df <- long_df %>% dplyr::select(all_of(output_cols), y)
# ==== Final Check ====
if (nrow(long_df) == 0) {
warning("No data remaining after filtering. Check sampletype_keep, min_species_sum, or col_vars.")
}
return(list(
physeq_filtered = physeq_bio_filtered,
long_df = long_df
))
}
out <- prepare_long_data(
physeq_obj = physeq,
min_species_sum = 20,
sampletype_keep = "biologicalsample",
col_vars = list(
sampletype = "sampletype",
location = "location",
treatment = "treatment",
sample = "sample",
samplerep = "samplerep",
atoll = "atoll"
)
)
out$long_df
col_map <- list(
sampletype = "sampletype",
location   = "location",
treatment  = "treatment",
sample     = "sample",
samplerep  = "samplerep",
atoll      = "atoll"
)
physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
physeq <- readRDS(physeq_path)
out_data <- prepare_long_data(
physeq_obj        = physeq,
min_species_sum   = 50,
sampletype_keep   = "biologicalsample",
col_vars          = col_map
)
out_data$long_df
devtools::load_all()
devtools::document()
rm(prepare_long_data)
devtools::load_all()
devtools::document()
devtools::build(args = "--no-manual")
devtools::build()
crab <- read.table("https://www.math.ntnu.no/emner/TMA4315/2018h/crab.txt")
colnames(crab) <- c("Obs", "C", "S", "W", "Wt", "Sa")
crab <- crab[,-1] #remove column with Obs
crab$C <- as.factor(crab$C)
modelEXAM <- glm(Sa ~ 1, family = "poisson", data = crab) #, contrasts =
list(C = "contr.sum"))
#' Multiply all formula terms (except offset) by `i`
#'
#' @param formula An R formula object.
#' @param interaction_var Character string, e.g., "i".
#'
#' @return A modified formula where all terms except offsets are multiplied by `interaction_var`.
multiply_all_terms_by <- function(formula, interaction_var = "i") {
# Extract LHS and RHS
lhs <- deparse(formula[[2]])
rhs <- deparse(formula[[3]])
# Split terms by '+' (not inside parentheses)
terms <- strsplit(rhs, "(?<!\\([^)]*)\\+", perl = TRUE)[[1]]
terms <- trimws(terms)
# Modify terms: multiply by interaction_var unless it's offset()
new_terms <- lapply(terms, function(term) {
if (grepl("^offset\\(", term)) {
return(term)
}
# Skip if already multiplied by interaction_var
if (grepl(paste0(":", interaction_var, "\\b|", interaction_var, ":"), term)) {
return(term)
}
# Return term with interaction
paste0("(", term, "):", interaction_var)
})
# Reconstruct formula
new_rhs <- paste(new_terms, collapse = " + ")
new_formula <- as.formula(paste(lhs, "~", new_rhs))
return(new_formula)
}
original_formula <- y ~ (1 | Site) + (1 | Sample) + treatment + offset(log_total_reads)
# Transform
new_formula <- multiply_all_terms_by(original_formula)
#' Multiply all formula terms (except offset) by `i`
#'
#' @param formula An R formula.
#' @param interaction_var Character, name of the variable to multiply by (e.g., "i").
#' @return A modified formula object.
multiply_all_terms_by <- function(formula, interaction_var = "i") {
# Convert to character for manipulation
lhs <- deparse(formula[[2]])
rhs_terms <- attr(terms(formula), "term.labels")
# Identify offset terms
offset_terms <- rhs_terms[grepl("^offset\\(", rhs_terms)]
other_terms <- setdiff(rhs_terms, offset_terms)
# Multiply all non-offset terms by interaction variable
interacted_terms <- paste0("(", other_terms, "):", interaction_var)
# Combine everything back
all_terms <- c(interacted_terms, offset_terms)
rhs_new <- paste(all_terms, collapse = " + ")
formula_new <- as.formula(paste(lhs, "~", rhs_new))
return(formula_new)
}
original_formula <- y ~ (1 | Site) + (1 | Sample) + treatment + offset(log_total_reads)
new_formula <- multiply_all_terms_by(original_formula)
print(new_formula)
multiply_all_terms_by <- function(formula, interaction_var = "i") {
# Extract LHS
lhs <- deparse(formula[[2]])
# Get RHS as a string
rhs_expr <- formula[[3]]
# Decompose the RHS into call components
rhs_terms <- all.vars(rhs_expr)
# Capture the full RHS structure
terms_obj <- terms(formula)
# Get individual term labels (excludes offset)
term_labels <- attr(terms_obj, "term.labels")
# Capture original RHS expression as text
rhs_text <- deparse(rhs_expr)
# Extract offset terms manually
offset_calls <- all.names(rhs_expr)
has_offset <- grepl("offset\\(", offset_calls)
offset_terms <- character(0)
if ("offset" %in% offset_calls) {
offset_terms <- grep("offset\\((.*?)\\)", rhs_text, value = TRUE)
# Or manually recover from expression:
offset_exprs <- Filter(function(x) is.call(x) && x[[1]] == as.name("offset"), as.list(rhs_expr))
offset_terms <- vapply(offset_exprs, function(x) paste0("offset(", deparse(x[[2]]), ")"), character(1))
}
# Remove offset terms from main term labels
non_offset_terms <- setdiff(term_labels, offset_terms)
# Multiply non-offset terms by interaction_var
interacted_terms <- paste0("(", non_offset_terms, "):", interaction_var)
# Combine all terms
rhs_combined <- c(interacted_terms, offset_terms)
rhs_new <- paste(rhs_combined, collapse = " + ")
# Reconstruct new formula
formula_new <- as.formula(paste(lhs, "~", rhs_new))
return(formula_new)
}
original_formula <- y ~ (1 | Site) + (1 | Sample) + treatment + offset(log_total_reads)
new_formula <- multiply_all_terms_by(original_formula)
print(new_formula)
out <- simulate_glm_burnin_iterations(
data_glm = otu_subset,
poisson_formula = y ~ (1|Site)*i + (1 | Sample)*i + (1 | Replicate)*i +treatment*i,
binomial_formula = z_sim ~ (1|Site)*i+ treatment*i,
num_iterations   = 100,
burn_in          = 50
)
devtools::load_all()
devtools::document
devtools::document()
devtools::load_all()
devtools::load_all()
devtools::check()   # run checks, tests, documentation, etc.
devtools::install("~/Documents/eDNAModel")
library(eDNAModel)
devtools::load_all("~/Documents/eDNAModel")
remove.packages("eDNAModel")
devtools::install("~/Documents/eDNAModel")
library(eDNAModel)
devtools::load_all("~/Documents/eDNAModel")
library(phyloseq)
library(eDNAModel)
library(dplyr)
library(tidyr)
library(tibble)
library(glmmTMB)
col_map <- list(
sampletype = "sampletype",
location   = "location",
treatment  = "treatment",
sample     = "sample",
samplerep  = "samplerep",
atoll      = "atoll"
)
physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
physeq <- readRDS(physeq_path)
out_data <- prepare_long_data(
physeq_obj        = physeq,
min_species_sum   = 50,
sampletype_keep   = "biologicalsample",
col_vars          = col_map
)
long_df <- out_data$long_df
build_formula_with_species_interaction <- function(rhs, response = "y", species_var = "i", lower_level = "Replicate") {
# Deparse the right-hand side formula into string
rhs_str <- paste(deparse(rhs), collapse = "")
# Split terms by "+" while respecting parentheses
terms <- strsplit(rhs_str, "\\s*\\+\\s*")[[1]]
terms <- trimws(terms)
# Process each term
new_terms <- vapply(terms, function(term) {
if (grepl("^offset\\s*\\(", term)) {
# Keep offset as-is
return(term)
} else if (grepl(lower_level, term)) {
# Do not multiply lower-level term by species
return(term)
} else {
# Multiply by species_var
return(paste0("(", term, ") * ", species_var))
}
}, character(1))
# Combine into a formula string
full_formula_str <- paste(response, "~", paste(new_terms, collapse = " + "))
# Return as formula object
as.formula(full_formula_str)
}
#' Simulate GLMMs for Multi-Species Occupancy-Abundance
#'
#' Iteratively fits Poisson and Binomial GLMMs with latent occupancy variable,
#' including burn-in iterations.
#'
#' @param data_glm A long-format data frame with species, covariates, and counts.
#' @param poisson_formula A formula for the Poisson (abundance) model.
#' @param binomial_formula A formula for the Binomial (occupancy) model.
#' @param num_iterations Total number of iterations to run.
#' @param burn_in Number of burn-in iterations to discard.
#' @param species_var The name of the species column (default: "i").
#'
#' @return A list of fitted Poisson and Binomial models post burn-in.
#' @export
simulate_glm_burnin_iterations <- function(data_glm,
poisson_formula,
binomial_formula,
num_iterations = 100,
burn_in = 50,
species_var = "i") {
# Step 1: Initialize latent occupancy variable
data_glm$z_sim <- ifelse(data_glm$y > 0, 1, rbinom(nrow(data_glm), 1, 0.5))
poisson_models <- list()
binomial_models <- list()
for (iter in 1:num_iterations) {
# Subset data where occupancy = 1
Q <- data_glm[data_glm$z_sim == 1, ]
# Step 2: Fit Poisson and Binomial models
model_poisson <- glmmTMB::glmmTMB(poisson_formula, family = poisson, data = Q)
model_binomial <- glmmTMB::glmmTMB(binomial_formula, family = binomial, data = data_glm)
# Step 3: Predict lambda (abundance) and P (occupancy)
lambda_i <- predict(model_poisson, type = "response", newdata = data_glm)
P_i <- predict(model_binomial, type = "response", newdata = data_glm)
# Step 4: Update z_sim based on posterior probability
prob_Z1_given_y0 <- P_i * exp(-lambda_i) / (P_i * exp(-lambda_i) + (1 - P_i))
prob_Z1_given_y0 <- pmin(pmax(prob_Z1_given_y0, 1e-6), 1 - 1e-6)
data_glm$z_sim[data_glm$y == 0] <-
rbinom(sum(data_glm$y == 0), 1, prob_Z1_given_y0[data_glm$y == 0])
# Step 5: Store models post burn-in
if (iter > burn_in) {
poisson_models[[iter - burn_in]] <- model_poisson
binomial_models[[iter - burn_in]] <- model_binomial
}
}
return(list(
poisson_models = poisson_models,
binomial_models = binomial_models
))
}
#' Fit Multi-species Occupancy-Abundance Model from Phyloseq
#'
#' Filters and reshapes a phyloseq object, builds species-interaction formulas,
#' and runs multi-species occupancy modeling via iterative GLMMs.
#'
#' @param physeq A phyloseq object
#' @param poisson_rhs Unquoted RHS of Poisson model (e.g. (1 | Site) + treatment)
#' @param binomial_rhs Unquoted RHS of Binomial model (e.g. (1 | Site) + treatment)
#' @param min_species_sum Minimum total abundance across all samples to retain a taxon
#' @param sampletype_keep Type of sample to retain (default: "biologicalsample")
#' @param num_iterations Total number of iterations
#' @param burn_in Number of burn-in iterations to discard
#'
#' @return A list with fitted models and the filtered data
#' @export
FitModel <- function(physeq,
poisson_rhs,
binomial_rhs,
min_species_sum = 50,
sampletype_keep = "biologicalsample",
num_iterations = 100,
burn_in = 50) {
# Step 1: Extract species names from OTU table
species_colname <- "i"
# Step 2: Prepare long-format data
long_data <- prepare_long_data(
physeq_obj = physeq,
min_species_sum = min_species_sum,
sampletype_keep = sampletype_keep
)
long_df <- long_data$long_df
# Step 3: Build full model formulas with species interaction
poisson_formula <- build_formula_with_species_interaction(
rhs = poisson_rhs,
response = "y",
species_var = species_colname
)
binomial_formula <- build_formula_with_species_interaction(
rhs = binomial_rhs,
response = "z_sim",
species_var = species_colname
)
message("ðŸ“Œ Poisson model formula: ", deparse(poisson_formula))
message("ðŸ“Œ Binomial model formula: ", deparse(binomial_formula))
# Step 4: Run simulation-based estimation
out <- simulate_glm_burnin_iterations(
data_glm = long_df,
poisson_formula = poisson_formula,
binomial_formula = binomial_formula,
num_iterations = num_iterations,
burn_in = burn_in
)
return(list(
poisson_models = out$poisson_models,
binomial_models = out$binomial_models,
long_df = long_df,
physeq_filtered = long_data$physeq_filtered
))
}
rhs <- quote((1 | Site) + (1 | Sample) + (1 | Replicate) + treatment)
build_formula_with_species_interaction(rhs, response = "y", species_var = "i", lower_level = "Replicate")
out <- FitModel(
physeq = physeq,
poisson_rhs = quote((1 | Site) + (1 | Sample) + (1 | Replicate) + treatment),
binomial_rhs = quote((1 | Site) + treatment),
num_iterations = 100,
burn_in = 50
)
devtools::load_all()
devtools::document()
devtools::document("eDNAModel")
devtools::document("marwah83/eDNAModel")
devtools::document("~/Documents/eDNAModel")
devtools::load_all()
rlang::last_trace()
devtools::load_all()
devtools::load_all()
