---
title: "eDNAModel: Updated Workflow with Phyloseq"
author: "Marwah Soliman, Bert van der Veen"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{eDNAModel: Updated Workflow with Phyloseq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r load-packages, message=FALSE, warning=FALSE}
library(phyloseq)
library(Matrix)
library(eDNAModel)
library(dplyr)
library(tidyr)
library(ggplot2)
library(pheatmap)
library(tibble)
```

# 1. Introduction

This vignette demonstrates the updated occupancy–detection model workflow using the `eDNAModel` package and `phyloseq` data objects. The workflow includes fitting binomial and Poisson mixed-effects models across iterations, visualizing occupancy and detection probabilities, and comparing models using AIC/BIC.

---

# 2. Load and Subset Data
```{r load-data}
physeq_new=readRDS("~/Downloads/BGE_Port_sampling.rds")
physeq_one=physeq_new$`Marine invasive species Thessaloniki`

#physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
#physeq <- readRDS(physeq_path)

# Subset 100 random OTUs
#set.seed(123)
#selected_otus <- sample(taxa_names(physeq), 100)
#physeq_100 <- prune_taxa(selected_otus, physeq)
```

---

# 3. Fit the Occupancy–Detection Model

```{r fit-model, echo=FALSE}
out=FitModel(
    phyloseq = physeq_one,
    site_col = "Sampling.area.Name",
    abundance_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU) +
                                 (1 | Name / OTU) + (1 | Replicate / OTU) + Samplingmonth * OTU,
    occupancy_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU),
  n_iter = 50,
  burn_in = 10
)
```

---

# 4. Visualization

## 4.1 Occupancy Probability Caterpillar Plot

```{r plot-detect, fig.width=10, fig.height=9}

# Summarize occupancy across treatments
psi_otu_summary <- out$summary %>%
    group_by(OTU) %>%
    summarise(
        psi_mean = mean(psi_mean, na.rm = TRUE),
        psi_lwr = mean(psi_lwr, na.rm = TRUE),
        psi_upr = mean(psi_upr, na.rm = TRUE),
        .groups = "drop"
    ) %>%
    arrange(psi_mean) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU)))

# Plot
ggplot(psi_otu_summary, aes(x = psi_mean, y = OTU)) +
    geom_point(color = "darkgreen") +
    geom_errorbarh(aes(xmin = psi_lwr, xmax = psi_upr), height = 0.2) +
    labs(
        title = "Caterpillar Plot: Occupancy Probability by OTU",
        x = "Occupancy Probability (ψ)",
        y = "OTU"
    ) +
    theme_minimal() +
    theme(
        axis.text.y = element_text(size = 8),
        plot.title = element_text(hjust = 0.5)
    )

```

---

## 4.2 Detection Probability Caterpillar Plot

```{r plot-occupancy,fig.width=10, fig.height=9}
# Summarize detection probability across treatments
p_detect_otu_summary <- out$summary %>%
    group_by(OTU) %>%
    summarise(
        p_detect_mean = mean(p_detect_mean, na.rm = TRUE),
        p_detect_lwr = mean(p_detect_lwr, na.rm = TRUE),
        p_detect_upr = mean(p_detect_upr, na.rm = TRUE),
        .groups = "drop"
    ) %>%
    arrange(p_detect_mean) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU)))

# Plot
ggplot(p_detect_otu_summary, aes(x = p_detect_mean, y = OTU)) +
    geom_point(color = "steelblue") +
    geom_errorbarh(aes(xmin = p_detect_lwr, xmax = p_detect_upr), height = 0.2) +
    labs(
        title = "Caterpillar Plot: Detection Probability by OTU",
        x = "Detection Probability (p)",
        y = "OTU"
    ) +
    theme_minimal() +
    theme(
        axis.text.y = element_text(size = 8),
        plot.title = element_text(hjust = 0.5)
    )

```

---

## 4.3 Occupancy by treatment

```{r plot-psi-Samplingmonth,fig.width=10, fig.height=9}
# Set treatment variable (replace if needed)
treatment_col <- "Samplingmonth"

# Prepare data
psi_data <- out$summary %>%
    select(OTU, all_of(treatment_col), psi_mean, psi_lwr, psi_upr) %>%
    group_by(OTU) %>%
    mutate(otu_mean = mean(psi_mean, na.rm = TRUE)) %>%
    ungroup() %>%
    arrange(otu_mean) %>%
    mutate(OTU = factor(OTU, levels = unique(OTU)))

# Plot with treatment as color
ggplot(psi_data, aes(x = psi_mean, y = OTU, color = .data[[treatment_col]])) +
    geom_point(position = position_dodge(width = 0.5)) +
    geom_errorbarh(
        aes(xmin = psi_lwr, xmax = psi_upr),
        position = position_dodge(width = 0.5),
        height = 0.2
    ) +
    labs(
        title = "Caterpillar Plot: Occupancy Probability by OTU and Treatment",
        x = "Occupancy Probability (ψ)",
        y = "OTU",
        color = treatment_col
    ) +
    theme_minimal() +
    theme(
        axis.text.y = element_text(size = 8),
        plot.title = element_text(hjust = 0.5)
    )

```

---

## 4.4 Clustered Heatmap of Occupancy Probabilities

```{r heatmap-psi,fig.width=10, fig.height=9}
# Load required libraries
library(dplyr)
library(tidyr)
library(tibble)
library(pheatmap)

# Set site column name
site_col <- "Sampling.area.Name"  # change if needed

# Step 1: Create Site × OTU matrix of psi_mean
psi_matrix <- out$summary %>%
  select(OTU, !!sym(site_col), psi_mean) %>%
  pivot_wider(
    names_from = OTU,
    values_from = psi_mean,
    values_fn = mean  # average if duplicates exist
  ) %>%
  column_to_rownames(site_col) %>%
  as.matrix()

# Step 2: Replace NAs (optional)
psi_matrix[is.na(psi_matrix)] <- 0  # Replace with 0 or other value

# Step 3: Plot the heatmap
pheatmap(
  psi_matrix,
  cluster_rows = TRUE,
  cluster_cols = TRUE,
  color = colorRampPalette(c("white", "darkblue"))(100),
  main = "Heatmap of Occupancy Probability (ψ): Sites × OTUs",
  fontsize_row = 8,
  fontsize_col = 7,
  angle_col = 45
)

```


```{r model-comparison-full, echo=FALSE}

##For example 

out1=FitModel(
    phyloseq = physeq_one,
    site_col = "Sampling.area.Name",
    abundance_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU) +
                                 (1 | Name / OTU) + (1 | Replicate / OTU) + Samplingmonth * OTU,
    occupancy_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU),
  n_iter = 50,
  burn_in = 10
)

out2 =FitModel(
    phyloseq = physeq_one,
    site_col = "Sampling.area.Name",
    abundance_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU) ,
    occupancy_rhs = (1 | OTU) + (1 | `Sampling.area.Name` / OTU),
  n_iter = 50,
  burn_in = 10
)

# Extract model metrics (AIC, BIC, NegLogLik) across multiple iterations
extract_model_metrics <- function(model_list) {
  metrics_df <- do.call(rbind, lapply(model_list, function(mod) {
    if (inherits(mod, "glmmTMB")) {
      data.frame(
        AIC = AIC(mod),
        BIC = BIC(mod),
        NegLogLik = -as.numeric(logLik(mod))
      )
    } else {
      warning("Non-glmmTMB object in list, skipping.")
      NULL
    }
  }))
  return(metrics_df)
}

# Extract metrics for each result object (after burn-in)
abun_metrics_out1 <- extract_model_metrics(out1$abundance_models)
abun_metrics_out2 <- extract_model_metrics(out2$abundance_models)

occ_metrics_out1 <- extract_model_metrics(out1$occupancy_models)
occ_metrics_out2 <- extract_model_metrics(out2$occupancy_models)

# Combine summary
summary_metrics <- data.frame(
  Model = c("abun_Out1", "abun_Out2", "occ_Out1", "occ_Out2"),
  AIC   = c(mean(abun_metrics_out1$AIC, na.rm = TRUE),
            mean(abun_metrics_out2$AIC, na.rm = TRUE),
            mean(occ_metrics_out1$AIC, na.rm = TRUE),
            mean(occ_metrics_out2$AIC, na.rm = TRUE)),
  BIC   = c(mean(abun_metrics_out1$BIC, na.rm = TRUE),
            mean(abun_metrics_out2$BIC, na.rm = TRUE),
            mean(occ_metrics_out1$BIC, na.rm = TRUE),
            mean(occ_metrics_out2$BIC, na.rm = TRUE)),
  NegLogLik = c(mean(abun_metrics_out1$NegLogLik, na.rm = TRUE),
                mean(abun_metrics_out2$NegLogLik, na.rm = TRUE),
                mean(occ_metrics_out1$NegLogLik, na.rm = TRUE),
                mean(occ_metrics_out2$NegLogLik, na.rm = TRUE))
)

# Display the result
print(summary_metrics)

############################ model comparison model as whole ############################

# Helper function to extract model metrics safely
extract_model_metrics <- function(model_list) {
  metrics_df <- do.call(rbind, lapply(model_list, function(mod) {
    if (inherits(mod, "glmmTMB")) {
      data.frame(
        AIC = AIC(mod),
        BIC = BIC(mod),
        NegLogLik = -as.numeric(logLik(mod))
      )
    } else {
      warning("Skipping non-glmmTMB model object.")
      NULL
    }
  }))
  return(metrics_df)
}

# Extract metrics for out1
abun_metrics_out1 <- extract_model_metrics(out1$abundance_models)
occ_metrics_out1 <- extract_model_metrics(out1$occupancy_models)

# Extract metrics for out2
abun_metrics_out2 <- extract_model_metrics(out2$abundance_models)
occ_metrics_out2 <- extract_model_metrics(out2$occupancy_models)

# Compute total (sum) of metrics across both models for each run
overall_metrics <- data.frame(
  Model = c("out1", "out2"),
  Total_AIC = c(
    sum(abun_metrics_out1$AIC, na.rm = TRUE) + sum(occ_metrics_out1$AIC, na.rm = TRUE),
    sum(abun_metrics_out2$AIC, na.rm = TRUE) + sum(occ_metrics_out2$AIC, na.rm = TRUE)
  ),
  Total_BIC = c(
    sum(abun_metrics_out1$BIC, na.rm = TRUE) + sum(occ_metrics_out1$BIC, na.rm = TRUE),
    sum(abun_metrics_out2$BIC, na.rm = TRUE) + sum(occ_metrics_out2$BIC, na.rm = TRUE)
  ),
  Total_NegLogLik = c(
    sum(abun_metrics_out1$NegLogLik, na.rm = TRUE) + sum(occ_metrics_out1$NegLogLik, na.rm = TRUE),
    sum(abun_metrics_out2$NegLogLik, na.rm = TRUE) + sum(occ_metrics_out2$NegLogLik, na.rm = TRUE)
  )
)

# Print the comparison summary
print(overall_metrics)
