---
title: "eDNAModel: Updated Workflow with Phyloseq"
author: "Marwah Soliman, Bert van der Veen"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    toc: true
    toc_depth: 3
    number_sections: true
vignette: >
  %\VignetteIndexEntry{eDNAModel: Updated Workflow with Phyloseq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup1, include=FALSE}
library(phyloseq)
library(Matrix)
library(TMB)
# Assume fit.phyloseq and summary.eDNAModel are defined in your package or sourced manually

```
---
```{r example, eval=TRUE}
# Create OTU table
# ----------------------------
# LOAD REQUIRED PACKAGE
# ----------------------------
library(phyloseq)
# ----------------------------
physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
physeq <- readRDS(physeq_path)
physeq_filtered <- filter_phyloseq_data(
  phyloseq_obj = physeq,
  min_species_sum = 50,
  save_path = "filtered_physeq.RDS"
)

table(sample_data(physeq_filtered)$sampletype)


# Subset only biological samples
physeq_bio <- subset_samples(physeq_filtered, sampletype == "biologicalsample")

sample_names_vec <- sample_names(physeq_bio)

parsed <- tryCatch({
  as.data.frame(strcapture(
    pattern = "^(.*)_r([0-9]+)$",
    x = sample_names_vec,
    proto = list(Sample = character(), Replicate = integer())
  ))
}, error = function(e) {
  message("⚠️ Pattern matching failed: ", e$message)
  data.frame(Sample = sample_names_vec, Replicate = 1)
})

parsed$Sample[is.na(parsed$Sample)] <- sample_names_vec[is.na(parsed$Sample)]
parsed$Replicate[is.na(parsed$Replicate)] <- 1

parsed$Sample <- factor(parsed$Sample)
parsed$Replicate <- factor(parsed$Replicate)

sample_data(physeq_bio)$Sample <- parsed$Sample
sample_data(physeq_bio)$Replicate <- parsed$Replicate
sample_data(physeq_bio)$SampleRep <- interaction(parsed$Sample, parsed$Replicate)

meta_df <- data.frame(phyloseq::sample_data(physeq_bio))
str(meta_df)

# 1. Copy and clean `location` as the new Site
meta_df$Site <- factor(trimws(meta_df$location))

# 2. Check it looks good
table(meta_df$Site)

# 3. Drop the old `location` column if desired
meta_df$location <- NULL

# 4. Reassign to phyloseq object
sample_data(physeq_bio) <- phyloseq::sample_data(meta_df)

levels(sample_data(physeq_bio)$Site)
table(sample_data(physeq_bio)$Site)


physeq_bio_filtered <- filter_taxa(physeq_bio, function(x) sum(x > 0) > 5, TRUE)

library(tidyverse)

# Extract OTU matrix
otu_mat <- as(otu_table(physeq_bio_filtered), "matrix")
if (taxa_are_rows(physeq_bio_filtered)) otu_mat <- t(otu_mat)

# Convert to long format
otu_long <- as.data.frame(otu_mat) %>%
  rownames_to_column(var = "SampleRep") %>%
  pivot_longer(-SampleRep, names_to = "i", values_to = "y")


# Extract sample metadata
meta_df <- data.frame(sample_data(physeq_bio_filtered))

# If 'SampleRep' already exists, drop it before adding rownames
if ("SampleRep" %in% colnames(meta_df)) {
  meta_df <- meta_df %>% select(-SampleRep)
}

# Add SampleRep from rownames
meta_df <- meta_df %>% rownames_to_column(var = "SampleRep")

# Merge metadata with OTU counts
long_df <- left_join(otu_long, meta_df, by = "SampleRep")


long_df <- long_df %>%
  mutate(
    s = Site,
    j = Sample,
    k = Replicate,
    x_site = 0,    # Set to covariate if you have one, else keep 0
    w = 1,         # Set to covariate if needed, else keep 1
    i = factor(i),
    y = as.integer(y)
  ) %>%
  select(i, s, j, k, x_site, w, y)

fit <- fit_occ_siteZIP_repl_glmm(
    df = long_df,
    iters = 500,
    burn_in = 100,
    a.formula = ~ Site + (1|SampleID) + (1|ReplicateID),  # abundance
    o.formula = ~ Site                                     # occupancy
)



#model <- fit.phyloseq(
  #phyloseq_obj = physeq_bio_filtered,
  #a.formula = ~ Site + diag(1 | Sample) + diag(1 | Replicate),
  #o.formula = ~ Site,
  #linko = 1,
  #linka = 0,
 # family = 1,
 # control = list(startOptcontrol = list(maxit = 200),
  #               optControl = list(maxit = 10e3, sigma1 = 0.25), trace = TRUE)
#)

##################### Model selection, randomly selection of 200 OTU####################################

# Ensure reproducibility
set.seed(42)

# Get all OTU/taxa names
all_otus <- taxa_names(physeq_bio_filtered)

# Randomly sample 200 OTUs
selected_otus <- sample(all_otus, 200)

# Subset phyloseq object
physeq_200 <- prune_taxa(selected_otus, physeq_bio_filtered)


model_full <- fit.phyloseq(
  phyloseq_obj = physeq_200,
  a.formula = ~ Site + diag(1 | Sample) + diag(1 | Replicate),
  o.formula = ~ Site,
  linko = 1,
  linka = 0,
  family = 1,  # ZINB
  control = list(
    startOptcontrol = list(maxit = 200),
    optControl = list(maxit = 1e4, sigma1 = 0.25),
    trace = FALSE
  )
)

---
```{r sum, eval=TRUE}

summary_df <- summary(model)
print(summary_df)
```
---
## Fitted Values

```{r fitted_summary, echo=FALSE}
fitted_vals <- fitted_TMB(model)

summary(fitted_vals$fitted_abundance)
summary(fitted_vals$fitted_occupancy)

```
---

##Residuals

```{r run_resid, eval = TRUE}
# Residuals
# Make sure compute_residuals_TMB is sourced beforehand
residuals <- compute_residuals_TMB(model, y = y, X = X, type = "pearson")

# Display a preview
cat("✅ Abundance residuals (first few rows):\n")
print(head(residuals$abundance_residuals))

cat("\n✅ Occupancy residuals (first few rows):\n")
print(head(residuals$occupancy_residuals))

hist(residuals$abundance_residuals, main = "Abundance Residuals", col = "lightblue")
hist(residuals$occupancy_residuals, main = "Occupancy Residuals", col = "lightgreen")

```
---

## Predictions

```{r run-pred, eval = TRUE}

# Create newdata with unique Site levels for fixed-effect prediction
newdata <- data.frame(Site = factor(levels(X$Site), levels = levels(X$Site)))

# Predict abundance on the response scale with CI
pred_abund <- predict_TMB(
  model = model,
  newX = newdata,
  formula = ~ Site,  # only fixed effect
  which = "abundance", 
  type = "response",
  se = TRUE
)
pred_occ <- predict_TMB(model, newX = newdata, formula = ~ Site, which = "occupancy", type = "response")

head(pred_abund)
head(pred_occ)

cat("✅ Abundance predictions:\n")
print(pred_abund)
cat("✅ Occupancy predictions:\n")
print(pred_occ)
```
---


## Introduction

The eDNAModel package provides a robust pipeline for analyzing environmental DNA (eDNA) using hierarchical multispecies occupancy-abundance models implemented via Template Model Builder (TMB).

1.This updated vignette demonstrates how to:

2.Load a phyloseq object

3.Automatically prepare the data using fit.phyloseq()

4.Fit the model with minimal effort

5.Extract and visualize residuals and predictions

---

## Load a phyloseq object

We'll use an example `.RDS` file located in `inst/extdata/`.

```{r load-data, eval = TRUE}
physeq_path <- system.file("extdata", "longdataexample.RDS", package = "eDNAModel")
physeq <- readRDS(physeq_path)
```

---

## Run the Full TMB Pipeline
We now use the high-level wrapper fit.phyloseq() which handles:

Extracting OTU table

Filtering biological samples

Adding Site, Sample, Replicate columns

Running the TMB pipeline


```{r model, eval = TRUE}
model <- fit.phyloseq(
  phyloseq_obj = physeq,
  a.formula = ~ Site + diag(1 | Sample) + diag(1 | Replicate),
  o.formula = ~ Site,
  linko = 1,
  linka = 0,
  family = 1,
  control = list(startOptcontrol = list(maxit = 200),
  optControl = list(maxit = 10e3, sigma1 = 0.25), trace = TRUE)
)
```
---

##Model Summary

```{r sum1, echo=FALSE}
summary_out <- summary(model)
head(summary_out)
```

```{r exp, echo=FALSE}
attr(summary_out, "explanation")
```
---

## Fitted Values

```{r fitted_summary, echo=FALSE}
fitted_vals <- fitted_TMB(model)

summary(fitted_vals$fitted_abundance)
summary(fitted_vals$fitted_occupancy)

```
---

##Residuals

```{r run_resid, eval = TRUE}
# Residuals
residuals <- compute_residuals_TMB(model = model, y = y, X = X, type = "pearson")

hist(residuals$abundance_residuals, main = "Abundance Residuals", col = "lightblue")
hist(residuals$occupancy_residuals, main = "Occupancy Residuals", col = "lightgreen")

```
---

## Predictions

```{r run-pred, eval = TRUE}
newdata <- unique(X[, "Site", drop = FALSE])
newdata$Site <- factor(newdata$Site)

pred_abund <- predict_TMB(model, newX = newdata, formula = ~ Site, which = "abundance", type = "response")
pred_occ <- predict_TMB(model, newX = newdata, formula = ~ Site, which = "occupancy", type = "response")

head(pred_abund)
head(pred_occ)


```
---

##Check for Boundary Cases

```{r run-H, eval = TRUE}
# Check for extreme occupancy values
high_occ <- fitted_vals$fitted_occupancy >= 0.999
low_occ <- fitted_vals$fitted_occupancy <= 0.001

if (any(high_occ)) {
  warning(sum(high_occ), " entries with occupancy ~1. Possible overfitting.")
}
if (any(low_occ)) {
  warning(sum(low_occ), " entries with occupancy ~0. Check sparsity.")
}

```
---

##  Hessian Diagnostic

```{r run-Hes, eval = TRUE}
H <- tryCatch({
  model$TMBobj$he()
}, error = function(e) {
  message("ℹ️ Hessian calculation skipped (random effects present).")
  NULL
})

if (!is.null(H)) {
  eigenvalues <- eigen(H)$values
  if (any(eigenvalues <= 0)) {
    warning("⚠️ Non-positive definite Hessian detected. Consider simplifying the model.")
  } else {
    message("✅ Hessian is positive definite.")
  }
}

```
---

You can extract model output such as slopes, intercepts, and model fit metrics from `result`.

---

## Summary

This vignette demonstrated how to:

-- Use fit.phyloseq() for end-to-end modeling

-- Interpret and visualize model output

-- Compute residuals and predictions

--Perform diagnostics

Explore the `eDNAModel` documentation for further customization and model diagnostics.
